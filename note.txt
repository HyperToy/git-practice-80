Git 入門コマンドライン演習80

p.76 git push --set-upstream option がわからない。

SSH 接続で、git push するときに毎回 passphrase を求められるのが面倒だった。
https://parashuto.com/rriver/tools/github-push-asks-passphrase-every-time
このページの対処を実行してみたところ、一旦解決したらしい。
書いてある通りに以下のコマンドを、理解しないまま打った。
    ssh-add -K ~/.ssh/id_rsa

p.81 git switch <branch name>
    ブランチを、 <branch name> に切り替える。
    ブランチの切り替えは、これまでずっと checkout を使っていた。

p.82 git switch -c <new branch name>
    ブランチの作成と切り替えを同時に行う。
    これまでは git checkout -b <branch name> を使っていた。

p.84 git merge <branch name>
    現在いるブランチに、指定したブランチをマージする。

p.92 git diff --cached / git diff --staged
    ステージングエリアとローカルリポジトリとの差分を確認することができる。
    つけるオプションはどちらでもいいらしい（細かい違いがある？）

    git status で表示されるもの
        Changes to be committed:            ← インデックス（ステージング）エリア
        Changes not staged for commit:      ← ワーキングツリー
        Untracked files:                    ←　それ以外


p.93 git log --oneline
    コミットログを省略して、1コミット1行で表示するオプション。
    とても便利な一方で、適切なコミットメッセージが求められるなと思った。


p.108 
    git branch --merged
        現在のブランチにマージされているブランチを出力する
    git branch --no-merged
        現在のブランチにマージされていないブランチを出力する
    git branch -d <branch name> 
        指定したブランチを削除する（現在いるブランチにマージされていない場合は、警告が出て失敗する）
    git branch -D <branch name>
        指定したブランチを削除する（現在いるブランチにマージされていなくても、削除を実行する）


p.110
    git branch -m <branch before> <branch after>
        ブランチの名前を変更する。
        <branch before> を省略した場合、現在いるブランチの名前を変更する。
        すでに同名のブランチが存在する場合、変更は失敗する
    git branch -M <branch before> <branch after>
        ブランチの名前を変更する。
        すでに同名のブランチが存在する場合でも、変更を実行する。
        前に存在した同名のブランチは、存在が消える。

p.112
    git fetch <remote repository> <remote branch>
        リモートリポジトリのリモートブランチの情報をローカルにコピーする。
        リモートリポジトリの名前には、 大抵、origin というエイリアスが張られている。
    
    git fetch 
        リモートリポジトリ名とリモートブランチ名を省略した場合、リモートブランチの情報をすべてローカルにコピーする。

p.113 practice 20 特定のコミットを取り入れる
    マージする = コミットの集合を取り入れる
    cherry-pick = 特定のコミットのみを取り入れる

    cherry-pick によってコンフリクトが発生した場合、選択肢は2つ
        - git cherry-pick --abort コマンドで、取り込みを中止する
        - ファイル編集でコンフリクトを解消した後、 git add コマンドでステージングし、 git cherry-pick --continue コマンドで確定する
            （エディタが開くので、コミットメッセージを入力する）
    
    git cherry-pick <commit>
    git cherry-pick <start commit>..<end commit>
        始点として指定したコミットの、次のコミットの変更から取り入れられる。
    git cherry-pick <branch name>
    git cherry-pick --continue
    git cherry-pick --abort

p.117 演習21 コミットからブランチを作成する
    git branch <branch name> <commit>
    git switch -c <branch name> <commit>
        ブランチ名を指定しない場合は、 detouched HEAD という状態になるらしい。（詳細は後述）

        自分の理解が正しければ、編集履歴は、「コミット」を頂点、「コミットとコミットの前後関係」を辺とする有向グラフとして考えられる。
        それぞれの「コミット」は、「変更差分」もしくは「編集内容」で、コミットが辺で繋がることによって、「編集履歴」を形成している。
        「ブランチ」は、連なったり分岐したりしている「コミットのツリー」のいずれかの頂点を指している。
        通常の状態の HEAD は、いずれかのブランチを指している。

9.2 操作を取り消そう①
    p.120 演習22 変更を取り消す①
        git restore <file name>
        git restore .
            ステージングされていない状態のワーキングツリーの変更を取り消す。
                （git add する前の変更を取り消すことができる。）
    
    p.122 演習23 コミットを修正する
        git commit --amend
        git commit --amend -m <commit message>
            直前のコミットのコミットメッセージを修正する。

    p.123 演習24 変更を取り消す②
        git reset HEAD
        git reset
        git reset -- <file naem>
            ステージングしている変更を、ステージング前に戻す。
            引数を省略した場合は、デフォルトで HEAD が補われる。

    p.126 演習25 変更を取り消す③
        git reset --soft HEAD^
            コミットをインデックスエリアまで戻す。
            ^ （カレット) は、 HEAD のいくつ前に戻すかを表す。上の場合は1つ前。
            コミットを取り消す。
                コミットとは、インデックスエリアの変更をローカルリポジトリに反映させること。
                コミットを取り消すと、変更がインデックスエリアに戻る。
            「git reset コマンドの --soft オプションは HEAD 飲みを変更し、 HEAD のみを前のコミットに戻しています。」
                 → HEAD の理解が甘いために、うまく飲み込めず。
    
    p.127 演習26 変更を取り消す④
        git reset --hard HEAD^
            変更前まで戻す
        git reset --mixed HEAD  # デフォルト
            ワーキングツリー まで戻す
        git reset --soft HEAD^
            インデックスエリア まで戻す

9.3 履歴に強くなろう②
    p.131 演習27 コミットを確認する②
        git log のオプション
            --oneline   各コミットを1行で出力
            --graph     グラフで表示
            --all       すべてのブランチ
            --pretty    フォーマット（プレースホルダーは色々ある）

    p.133 演習28 ファイルの差分を確認する②
        git diff <branch name1> <branch name2> <file name>
            指定したファイルの、ブランチ間の差分を出力
            2つのブランチは .. で繋ぐことでも指定できる
            ファイルを省略した場合は、ブランチ間の差分が単純に出力される（すべてのファイル以上の含意がある？）

    p.135 演習29 コミットの中身を確認する
        git show
        git show <commit>
        git show <commit>:<file name>
            コミットを指定しない場合は、直前のコミットの変更を出力する
            --oneline で簡略化できる

    p.138 演習30 作業履歴を確認する
        git reflog
        git reflog -<作業履歴数>
        git reflog --pretty
            コミットだけでなく、マージ、リセットなどの作業も追跡できるらしい。
            HEAD を移動するような操作を出力している。
            つまり、 HEAD に関する作業を追跡できる。
            
9.4 コマンドを組み合わせよう
    p.141 演習31 ファイルとディレクトリを削除する
        git rm <file name>
            ファイルを削除した上で、「削除」という変更をステージングまで行う。
            単純な rm コマンドを使うと、別途 git add が必要になる。
        git rm -r <directory name>
            ディレクトリを削除・ステージングするには、 -r オプションをつける。
    
    p.145 演習32 ファイル名とディレウトリ名を変更する
        git mv <before file> <after file>
            ファイル名を変更した上で、「変更(renamed)」という変更をステージングまで行う。
            単純な mv コマンドを使うと、削除したファイルと新規追加したファイルを、別途 git add する必要がある。
            deleted: と added: に分かれるのではなく、 renamed というステータス(?)になる。
        git mv <before dir> <after dir>
            同上。

    p.148 演習33 リモートブランチをまーじする
        リモートには、 main ブランチが存在している。
        ローカルには、 main ブランチと origin/main ブランチが存在している（とする）。
        git fetch すると、リモートの main ブランチの情報を取ってきて、それを origin/main とする。
        マージを行うことで、ローカルの main ブランチに、ローカルの origin/main ブランチの内容を反映する。

        git fetch と git merge origin/main とを同時に行うコマンドが、 git pull origin main ということになる。
        
